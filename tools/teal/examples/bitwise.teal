// Generate uint64 word to represent CONTRACT_ID_BYTES: 
// - The first 6 bytes are random, unique for the parties in the multisig
// - The last 2 bytes are "00 00"
printf "$(openssl rand -hex 6)0000" | xxd -r -p > contract_id_index.dat

//>> CONTRACT_ID_BYTES=$(openssl rand -hex 6)0000
//>> TMPL_CONTRACT_ID_INT=$(printf "%u\n" "0x$CONTRACT_ID_BYTES")
//
// Convert contract identifier (uint64) to base64
//// ARG_CONTRACT_ID=$(printf $CONTRACT_ID_BYTES | xxd -r -p | base64)
//// echo $TMPL_CONTRACT_ID_INT
ARG_BASE64_CONTRACT_ID_CONCAT_INDEX=$(xxd -r -p contract_id_index.dat | base64)
// TMPL_CONTRACT_ID_INT=$(base64 contract_id.dat)
//
// Update your teal code with the TMPL_ values
// Save your teal code
//
// Both parties must sign TMPL_CONTRACT_ID_INT and exchange signed data with eachother 
// goal clerk tealsign --data-b64 $TMPL_CONTRACT_ID_INT --contract-addr $TEAL_CONTRACT -d $DATA
//
// ?? How do you get the keyfile from kmd?

// FILE_HEX_CONTRACT_ID_CONCAT_PADDING (contract_id_concat_padding.dat)
// TMPL_INT_CONTRACT_ID_CONCAT_PADDING
// TMPL_INT_CONTRACT_INDEX
// FILE_TO_SIGN_HEX_CONTRACT_ID_CONCAT_INDEX (contract_id_concat_index.dat)
// ARG_BASE64_CONTRACT_ID_CONCAT_INDEX (data)
// ARG_SIGNED_CONTRACT_ID_CONCAT_INDEX (sig)
// TMPL_MULTISIG_PUBKEY                (pubkey)


// Generate uint64 word to represent CONTRACT_ID_CONCAT_PADDING and write results to contract_id_concat_padding.dat:
// - The first 6 bytes are randomly generated by openssl. Ensure this unique for the set comprising the multisig
// - The last 2 bytes are padding "0000"
// CONTRACT_ID=$(printf $(openssl rand -hex 6))
// CONTRACT_ID_CONCAT_PADDING=$CONTRACT_ID"0000"
// printf $CONTRACT_ID_CONCAT_PADDING | xxd -r -p > contract_id_concat_padding.dat
//
// Convert CONTRACT_ID_CONCAT_PADDING (uint64) to base64 for use as TMPL_INT_CONTRACT_ID_CONCAT_PADDING
// TMPL_INT_CONTRACT_ID_CONCAT_PADDING=$(printf "%s\n" "0x$CONTRACT_ID_CONCAT_PADDING")
//
// Define TMPL_INT_CONTRACT_INDEX for this contract state. 
// - This will always be higher than previously used index values used by CONTRACT_ID_CONCAT_PADDING
// TMPL_INT_CONTRACT_INDEX=11
//
// Convert TMPL_INT_CONTRACT_INDEX to HEX
// HEX_CONTRACT_INDEX=000b
//
// HEX_CONTRACT_ID_CONCAT_INDEX=$CONTRACT_ID$HEX_CONTRACT_INDEX
//
// Write HEX_CONTRACT_ID_CONCAT_INDEX to contract_id_concat_index.dat
// printf "%\n" "0x$HEX_CONTRACT_ID_CONCAT_INDEX" | xxd -r -p > contract_id_concat_index.dat

// 429F7909F01E0000 -> 4800688811390402560
// 429F7909F01E000B -> 4800688811390402571 -> Qp95CfAeAAs=
// DATA
// SIGNATURE
// PUBKEY 

// printf "%s\n" "429F7909F01E000B" | xxd -r -p > contract_id_concat_index.dat
// hexdump -C contract_id_concat_index.dat
// ARG_BASE64_CONTRACT_ID_CONCAT_INDEX=$(base64 contract_id_concat_index.dat)
//
// mkdir -p keys
// export TMPL_ACCOUNT_A=$($algokey generate -f keys/A | tail -1 | awk '{ print $3 }')
//
// export CLAIM_CONTRACT=$($goal clerk compile bitwise.teal -o bitwise.tealc | awk '{ print $2 }')
//
// goal clerk send -F bitwise.teal -t $CLAIM_CONTRACT -a 0 --close-to $CLAIM_CONTRACT -o claim.utx -d $DATA
// goal clerk tealsign --data-file contract_id_concat_index.dat --keyfile keys/A --lsig-txn claim.utx --set-lsig-arg-idx 1 -d $DATA
//
// 

arg 0                    // DATA: ARG_BASE64_CONTRACT_ID_CONCAT_INDEX Qp95CfAeAAs=
arg 1                    // SIGNATURE: provided by tealsign
addr LMDXDC2RDETFQAJ5SRLFPXWO7AFKG5E3UFUGNOSRPIUA3JPQPQZUI773IU      // PUBKEY: TMPL_ACCOUNT_A
ed25519verify            // Verify signature

arg 0                    // Load arg_0 (ARG_BASE64_CONTRACT_ID_CONCAT_INDEX)
btoi                     // Convert bytes to int
int 18446744073709486080 // Define the mask as 0xFFFFFFFFFFFF0000
&                        // Evaluate the converted 8 byte word using bitwise and with the mask
int 4800688811390402560  // $TMPL_INT_CONTRACT_ID_CONCAT_PADDING is our 6 byte contract identifier + 2 bytes padding
==                       // Evaluate for equality

arg 0                    // Load arg_0 (ARG_BASE64_CONTRACT_ID_CONCAT_INDEX)
btoi                     // Convert bytes to int
int 65535                // Define the mask as 0x000000000000FFFF
&                        // Evaluate the converted 8 byte word using bitwise and with the mask
int 1                    // $TMPL_INT_CONTRACT_INDEX is 2 bytes defining the index for this contract instance
==                       // Evaluate for equality
&&                       // Evaluate both clauses





// From the CLI enter the following commands:
// export TEAL_CONTRACT=$($goal clerk compile bitwise.teal | awk '{ print $2 }')
// >export TEAL_CONTRACT=$(goal clerk compile bitwise.teal | awk '{ print $2 }')
// goal clerk send -a 1000 -f $TEAL_CONTRACT -t $ACCOUNT_B -o test_bitwise.utxn -d $DATA
// 
// goal clerk sign -i test_bitwise.utxn -o test_bitwise.stxn -p bitwise.teal --argb64 $ARG_CONTRACT_ID -d $DATA
// goal clerk dryrun -t test_bitwise.stxn
//
// GOAL: Use bitwise-and (opcode &) to mask the first 6 bytes of an 8 byte word. 
// The resulting bit pattern should be 00000000 00001111
//
// BACKGROUND: TEAL provides the & opcode which consumes two uint64 items from
// the stack, then perform A bitwise-and B and push the resulting uint64 back to
// the stack. I cannot find examples using this opcode, so I attempted to apply
// my (limited) understanding of bit masking for testing. 
//
// TESTING: First, I needed to build a word and b64 encode it. I used "AA10" 
// which encodes to "should be byte string "0x4141000a".
//
// QUESTIONS: 
//
// END 
// Other personal notes:
// cryptii.com
// text >> int decode u16 >> bytes hex >> base64 encode >> text 
// printf "%u\n" "0x000000000000FFFF"
// 00 01 10 65535 // goal clerk sign -i test_bitwise.utxn -o test_bitwise.stxn --argb64 AA== --argb64 AQ== --argb64 AAo= --argb64 //8= --argb4 QUEAAA== --argb5 QUEAAQ== --argb6 QUEACg== --argb7 QUH//w== -p bitwise.teal -d $DATA
// AA00 AA01 AA10 AA65535 // goal clerk sign -i test_bitwise.utxn -o test_bitwise.stxn --argb64 QUEAAA== --argb64 QUEAAQ== --argb64 QUEACg== --argb64 QUH//w== -p bitwise.teal -d $DATA
// AA00 AA01 AA10 0000000000001111 // goal clerk sign -i test_bitwise.utxn -o test_bitwise.stxn --argb64 QUEAAA== --argb64 QUEAAQ== --argb64 QUEACg== --argb64 AAAAAAAAERE= -p bitwise.teal -d $DATA
